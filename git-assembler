#!/usr/bin/env python3
# git-assembler: update git branches using high-level assembly instructions
# Copyright(c) 2019 by wave++ "Yuri D'Elia" <wavexx@thregr.org>
# Distributed under the GNU GPLv3+ license, WITHOUT ANY WARRANTY.
import subprocess as sp
import argparse
import os, sys
import shutil
import json
from enum import Enum, IntEnum

import logging
from logging import error, warning, info, debug

APP_DSC = "update git branches using high-level assembly instructions"
APP_SIG = "git-assembler"
APP_VER = "1.0"


def repo_root():
    try:
        line = sp.check_output(['git', 'rev-parse', '--show-toplevel'])
    except sp.CalledProcessError as e:
        return None
    return line.decode(sys.getfilesystemencoding()).rstrip()


def assembly_path(root):
    path = os.path.join(root, '.git', 'assembly')
    if os.path.exists(path):
        return path
    path = os.path.join(root, '.gitassembly')
    if os.path.exists(path):
        return path
    return None


def parse_error(path, line, msg):
    error('{}:{}: {}'.format(path, line, msg))

def os_error(e):
    error(str(e))


def parse_assembly(path):
    try:
        fd = open(path)
    except OSError as e:
        os_error(e)
        return None

    nodes = {}
    for n, line in enumerate(fd, 1):
        # strip comments
        line = line[0:line.find('#')].strip()
        if len(line) == 0:
            continue

        # basic tokenization
        tokens = line.split()
        if len(tokens) < 3:
            parse_error(path, n, 'invalid assembly line')
            return None
        cmd, branch, args = tokens[0], tokens[1], tokens[2:]
        if cmd not in {'base', 'merge', 'rebase', 'stage'}:
            parse_error(path, n, 'unknown command: {}'.format(cmd))
            return None

        node = nodes.get(branch)
        if node is None:
            node = empty_node(branch)
            nodes[branch] = node

        if cmd in {'base', 'rebase', 'stage'}:
            # define the branch base
            if node['base']:
                parse_error(path, n, 'branch base/type cannot be redefined')
                return None
            if len(args) != 1:
                parse_error(path, n, 'invalid base for branch {}'.format(branch))
                return None
            node['base'] = args[0]
            if cmd == 'stage':
                node['type'] = BranchType.STAGE
            elif cmd == 'rebase':
                node['type'] = BranchType.REBASE
            else:
                node['type'] = BranchType.BASE
        elif cmd == 'merge':
            # add dependencies
            for arg in args:
                if arg in node['merge']:
                    parse_error(path, n, 'duplicate merge of {} into {}'.format(arg, branch))
                    return None
            node['merge'].extend(args)

    return nodes


class BranchType(Enum):
    BRANCH = 0 # regular branch (no base)
    BASE   = 1 # optional bootstrapping
    REBASE = 2 # rebase when needed
    STAGE  = 3 # bootstrap on any change

def leaf_node(node):
    return len(node['deps']) == 0

def empty_node(name):
    return {'name': name,
            'base': None,
            'type': BranchType.BRANCH,
            'merge': [],
            'deps': [],
            'state': {'dirty': False,
                      'used': False,
                      'missing': None}}


def assembly_graph(nodes, targets=None):
    # convert all nodes
    for branch in list(nodes):
        node = nodes[branch]
        deps = []

        # convert base
        if node['base'] is not None:
            base_name = node['base']
            base_node = nodes.get(base_name)
            if base_node is None:
                base_node = empty_node(base_name)
                nodes[base_name] = base_node
            node['base'] = base_node
            deps.append(base_node)

        # direct merge dependencies
        merge = []
        for branch_name in node.get('merge'):
            branch_node = nodes.get(branch_name)
            if branch_node is None:
                branch_node = empty_node(branch_name)
                nodes[branch_name] = branch_node
            merge.append(branch_node)
        node['merge'] = merge
        deps.extend(merge)

        # all dependencies (in order)
        node['deps'] = deps

    # filter targets
    if targets is None:
        left = set(nodes)
    else:
        left = set(targets)
        branches = set(nodes)
        for branch in targets:
            if branch not in branches:
                error('unknown branch {}'.format(branch))
                return None

    # find roots
    connected = set()
    for branch in left:
        for dep in nodes[branch]['deps']:
            connected.add(dep['name'])
    roots = set(left) - connected
    if len(roots) == 0:
        # graph has no root nodes, instead of exiting immediately pick a
        # random node to produce a more useful message later
        roots.add(next(iter(left)))

    # check for cycles
    stack = [(root, set()) for root in roots]
    while len(stack):
        branch, seen = stack.pop()
        if branch in seen:
            error('dependency cycle detected for branch {}'.format(branch))
            return None
        seen.add(branch)
        for dep in nodes[branch]['deps']:
            if not leaf_node(dep):
                stack.append((dep['name'], set(seen)))

    # return root nodes
    return [nodes[name] for name in sorted(roots)]


class Ansi:
    BOLD  = "\033[;1m"
    GREEN = "\033[0;32m"
    RED   = "\033[1;31m"
    RESET = "\033[0;0m"

def color_node(node):
    name = node['name']
    if not sys.stdout.isatty():
        return name
    elif node['state']['missing']:
        return Ansi.RED + name + Ansi.RESET
    elif node['state']['dirty']:
        return Ansi.BOLD + name + Ansi.RESET
    elif node['state']['used']:
        return Ansi.GREEN + name + Ansi.RESET
    else:
        return name

def dump_graph(graph, root=None, depth=0):
    roots = list(reversed(graph))
    if root is None:
        root = roots

    while len(roots):
        node = roots.pop()
        prefix = '  ' * depth

        # calculate an extended suffix
        suffix = ''
        base_node = node['base']
        while base_node is not None:
            if node['type'] == BranchType.STAGE:
                suffix += ' <= '
            elif node['type'] == BranchType.REBASE:
                suffix += ' <- '
            else:
                suffix += ' .. '
            base_name = color_node(base_node)
            if base_node['base'] is not None and len(base_node['merge']) != 0:
                # split the branch into a fake root
                suffix += '[' + base_name + ']'
                if base_node not in root:
                    root.append(base_node)
                break
            suffix += base_name
            base_node = base_node['base']

        print(prefix + color_node(node) + suffix)

        merge = node['merge']
        if len(merge):
            dump_graph(merge, root, depth + 1)


def topo_sort(graph, seen=None):
    if seen is None:
        seen = set()
    nodes = []
    if type(graph) is not list:
        graph = [graph]
    for node in graph:
        name = node['name']
        if name in seen:
            continue
        seen.add(name)
        for dep in node['deps']:
            nodes.extend(topo_sort(dep, seen))
        nodes.append(node)
    return nodes


def mark_tree_dirty(node, graph):
    if type(graph) is not list:
        graph = [graph]
    dirty = False
    for root in graph:
        if root is node or mark_tree_dirty(node, root['deps']):
            root['state']['dirty'] = dirty = True
    return dirty


def needs_merge(dst, branch):
    proc = sp.run(['git', 'merge-base', '--is-ancestor', branch, dst],
                  stderr=sp.DEVNULL)
    if proc.returncode not in [0, 1]:
        return None
    return proc.returncode != 0


def fork_point(dst, base):
    proc = sp.run(['git', 'merge-base', '--fork-point', base, dst],
                  stdout=sp.PIPE, stderr=sp.DEVNULL)
    fork_point = proc.stdout.decode('ascii').rstrip()
    if proc.returncode != 0 or len(fork_point) == 0:
        return None
    return fork_point


def branch_tip(name):
    proc = sp.run(['git', 'rev-parse', '--verify', name],
                  stdout=sp.PIPE, stderr=sp.DEVNULL)
    tip = proc.stdout.decode('ascii').rstrip()
    if proc.returncode != 0 or len(tip) == 0:
        return None
    return tip


def needs_rebase(dst, base):
    tip = branch_tip(base)
    if tip is None:
        return None, None, None
    fp = fork_point(dst, base)
    if fp is None:
        return None, None, None
    return tip != fp, tip, fp


def branch_exists(name):
    proc = sp.run(['git', 'rev-parse', '--verify', name],
                  stdout=sp.DEVNULL, stderr=sp.DEVNULL)
    return proc.returncode == 0


def node_missing(node):
    if node['state']['missing'] is None:
        node['state']['missing'] = not branch_exists(node['name'])

def nodes_missing(nodes):
    for node in nodes:
        node_missing(node)


def update_state(ordered_nodes, graph):
    for node in ordered_nodes:
        if leaf_node(node):
            continue

        if node['base'] is not None:
            if node['type'] == BranchType.BASE:
                # base should be created only when missing
                nodes_missing([node, node['base']])
                if node['state']['missing']:
                    node['base']['state']['used'] = True
                    mark_tree_dirty(node, graph)
            else:
                # always check if rebase is needed
                if node['state']['missing'] or node['base']['state']['missing']:
                    ret = None
                else:
                    ret = needs_rebase(node['name'], node['base']['name'])[0]
                if ret is not False:
                    if ret is None:
                        nodes_missing([node, node['base']])
                    node['base']['state']['used'] = True
                    mark_tree_dirty(node, graph)

        # merge dependencies
        for dep in node['merge']:
            if node['state']['missing'] or dep['state']['missing']:
                ret = None
            else:
                ret = needs_merge(node['name'], dep['name'])
            if ret is not False:
                if ret is None:
                    nodes_missing([node, dep])
                mark_tree_dirty(node, graph)
                dep['state']['used'] = True
                if node['type'] == BranchType.STAGE:
                    node['base']['state']['used'] = True


def check_missing(nodes, create):
    state = True
    for node in nodes:
        if node['state']['missing']:
            if node['base'] is None:
                # find the branch requiring node
                state = False
                for ref in nodes:
                    if node in ref['deps']:
                        break
                else:
                    ref = None
                if ref is None:
                    error('branch {} is required but does not exist'.format(color_node(node)))
                else:
                    error('branch {} is required by {} but does not exist'.format(color_node(node), color_node(ref)))
            elif node['type'] != BranchType.STAGE and not create:
                # prevent creation unless explicitly allowed
                state = False
                error('branch {} needs creation from {}'.format(color_node(node), color_node(node['base'])))
    return state


def check_dirty(nodes):
    for node in nodes:
        if node['state']['dirty']:
            return True
    return False


def current_branch():
    proc = sp.run(['git', 'rev-parse', '--abbrev-ref', 'HEAD'],
                  stdout=sp.PIPE, stderr=sp.DEVNULL)
    name = proc.stdout.decode('ascii').rstrip()
    if proc.returncode != 0 or len(name) == 0:
        return None
    return name


def read_state(root):
    state_path = os.path.join(root, '.git', 'as-cache', 'state')
    if os.path.exists(state_path):
        return json.load(open(state_path))
    else:
        return {}


def save_state(root, state):
    cache_dir = os.path.join(root, '.git', 'as-cache')
    dir_exists = os.path.exists(cache_dir)
    if not state:
        if dir_exists:
            shutil.rmtree(cache_dir)
        return
    if not dir_exists:
        os.mkdir(cache_dir)
    state_path = os.path.join(cache_dir, 'state')
    json.dump(state, open(state_path, "w"))


def switch_to_branch(name):
    proc = sp.run(['git', 'checkout', '-q', '--no-guess', name],
                  stdout=sp.DEVNULL, stderr=sp.DEVNULL)
    return proc.returncode == 0


def update_node(node, state, dry_run):
    if not node['state']['dirty']:
        return True

    # logging helper
    def log(prio, msg):
        state['last_msg'] = msg
        if dry_run and prio >= logging.INFO:
            prio = logging.WARNING
        logging.log(prio, msg)

    if node['type'] == BranchType.STAGE:
        # switch to base branch, erase target (if exists)
        if node['base']['name'] != state['last_branch']:
            log(logging.DEBUG, 'switching to branch {}'.format(color_node(node['base'])))
            if not dry_run:
                if not switch_to_branch(node['base']['name']):
                    return False
            state['last_branch'] = node['name']
        if not node['state']['missing']:
            log(logging.INFO, 'erasing existing branch {}'.format(color_node(node)))
            if not dry_run:
                proc = sp.run(['git', 'branch', '-q', '-D', node['name']])
                if proc.returncode != 0:
                    return False
        exists = False
    elif node['name'] == state['last_branch']:
        exists = True
    else:
        # switch to target
        log(logging.DEBUG, 'switching to branch {}'.format(color_node(node)))
        if dry_run:
            exists = branch_exists(node['name'])
        else:
            exists = switch_to_branch(node['name'])

    if not exists:
        # branch is missing, bootstrap
        log(logging.INFO, 'creating branch {} from {}'.format(color_node(node), color_node(node['base'])))
        if not dry_run:
            proc = sp.run(['git', 'checkout', '-q', '--no-guess', '-b', node['name'], node['base']['name']])
            if proc.returncode != 0:
                return False
        state['last_branch'] = node['name']
    else:
        state['last_branch'] = node['name']

        # rebase when required
        if node['type'] == BranchType.REBASE and node['base'] is not None:
            dirty, tip, fp = needs_rebase(node['name'], node['base']['name'])
            if dirty is None:
                return False
            elif dirty:
                log(logging.INFO, 'rebasing {} onto {}'.format(color_node(node), color_node(node['base'])))
                if not dry_run:
                    proc = sp.run(['git', 'rebase', '-q', '--rebase-merges',
                                   '--onto', node['base']['name'], fp, node['name']])
                    if proc.returncode != 0:
                        return False


    # merge dependencies
    for dep in node['merge']:
        if not exists or dep['state']['dirty']:
            # branch is new or dependency has been updated earlier on,
            # there's no need to peform another check: we need to merge
            pass
        elif not needs_merge(node['name'], dep['name']):
            continue

        log(logging.INFO, 'merging {} into {}'.format(color_node(dep), color_node(node)))
        if not dry_run:
            proc = sp.run(['git', 'merge', '-q', '--rerere-autoupdate', '--no-edit', dep['name']])
            if proc.returncode == 1:
                # directly attempt to autocommit in case rerere was successful
                proc = sp.run(['git', 'commit', '-q', '--no-edit'])
                if proc.returncode == 0:
                    log(logging.WARN, 'automatic merge resolution successful')
            if proc.returncode != 0:
                return False

    return True


def check_pending(root):
    git_root = os.path.join(root, '.git')
    if os.path.exists(os.path.join(git_root, 'MERGE_HEAD')):
        error('merge in progress, refusing to continue')
        return True
    elif os.path.exists(os.path.join(git_root, 'rebase-apply')):
        error('rebase in progress, refusing to continue')
        return True
    elif os.path.exists(os.path.join(git_root, 'BISECT_LOG')):
        error('bisect in progress, refusing to continue')
        return True
    return False


class ExitStatus(IntEnum):
    SUCCESS = 0
    ERROR   = 1
    CONFIG  = 2

def main(argv):
    ap = argparse.ArgumentParser(description=APP_DSC)
    ap.add_argument('-a', '--assembly', metavar='PATH',
                    help='explicit path to assembly file')
    ap.add_argument('-c', '--create', action='store_true',
                    help='create required branches')
    ap.add_argument('-n', '--dry-run', action='store_true',
                    help='do not modify the repository')
    ap.add_argument('-s', '--state', action='store_true',
                    help='show repository state')
    ap.add_argument('-v', '--verbose', default=0, action='count',
                    help='increase verbosity')
    ap.add_argument('--version', action='version', version=APP_VER)
    ap.add_argument('target', nargs='*',
                    help='branch to update')
    args = ap.parse_args(argv[1:])

    # logging
    levels = (logging.WARNING, logging.INFO, logging.DEBUG)
    logging.basicConfig(level=levels[min(len(levels)-1, args.verbose)],
                        format='{}: %(message)s'.format(APP_SIG))

    # assembly path
    root = repo_root()
    if root is None:
        return ExitStatus.CONFIG

    if args.assembly:
        path = args.assembly
    else:
        path = assembly_path(root)
        if path is None:
            error('no assembly instructions')
            return ExitStatus.CONFIG
        path = os.path.relpath(path)
        debug('reading instructions from {}'.format(path))

    # build the list of nodes and resulting graph
    nodes = parse_assembly(path)
    if nodes is None:
        return ExitStatus.CONFIG
    targets = set(args.target) if len(args.target) else None
    graph = assembly_graph(nodes, targets)
    if graph is None:
        return ExitStatus.CONFIG
    if len(graph) == 0:
        error('nothing to do')
        return ExitStatus.CONFIG

    # update and check current state
    ordered_nodes = topo_sort(graph)
    update_state(ordered_nodes, graph)
    if args.state:
        dump_graph(graph)
        return ExitStatus.SUCCESS
    if not check_missing(ordered_nodes, args.create):
        return ExitStatus.ERROR

    # check worktree state
    state = read_state(root)
    state['last_branch'] = current_branch()
    dirty = check_dirty(ordered_nodes)

    # exit early when possible
    if not dirty:
        if state.get('start_branch', state['last_branch']) == state['last_branch']:
            info('already up to date')
            if not args.dry_run:
                save_state(root, None)
            return ExitStatus.SUCCESS

    # refuse to continue if any stateful git operation is pending
    if check_pending(root):
        return ExitStatus.ERROR

    # perform the required operations
    if 'start_branch' in state:
        start_set = False
    else:
        state['start_branch'] = state['last_branch']
        start_set = True

    for node in ordered_nodes:
        state['last_msg'] = None
        if not update_node(node, state, args.dry_run):
            if not args.dry_run:
                save_state(root, state)
            msg = state['last_msg']
            if msg is not None:
                error('error while ' + msg)
            warning('stopping at branch {}, fix/commit then re-run {}'.format(
                color_node(nodes[state['last_branch']]), APP_SIG))
            return ExitStatus.ERROR

    # restore initial branch
    if state['start_branch'] != state['last_branch']:
        level = logging.INFO if start_set else logging.WARNING
        branch_name = color_node(nodes[state['start_branch']])
        logging.log(level, 'restoring initial branch {}'.format(branch_name))
        if not args.dry_run:
            switch_to_branch(state['start_branch'])
    if not args.dry_run:
        save_state(root, None)
    return ExitStatus.SUCCESS


if __name__ == '__main__':
    exit(main(sys.argv))
