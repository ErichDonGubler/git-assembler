#!/usr/bin/env python3
import subprocess as sp
import collections
import argparse
import os, sys
import shutil
import json

import logging
from logging import error, warning, info, debug

APP_DSC = "update git branches using high-level assembly instructions"
APP_SIG = "git-assembly"
APP_VER = "1.0"


def repo_root():
    try:
        line = sp.check_output(['git', 'rev-parse', '--show-toplevel'])
    except sp.CalledProcessError as e:
        return None
    return line.decode(sys.getfilesystemencoding()).rstrip()


def assembly_path(root):
    path = os.path.join(root, '.git', 'assembly')
    if os.path.exists(path):
        return path
    path = os.path.join(root, '.gitassembly')
    if os.path.exists(path):
        return path
    return None


def parse_error(path, line, msg):
    error('{}:{}: {}'.format(path, line, msg))

def os_error(e):
    error(str(e))


def parse_assembly(path):
    try:
        fd = open(path)
    except OSError as e:
        os_error(e)
        return None

    nodes = {}
    for n, line in enumerate(fd, 1):
        # strip comments
        line = line[0:line.find('#')].strip()
        if len(line) == 0:
            continue

        # basic tokenization
        tokens = line.split()
        if len(tokens) < 3:
            parse_error(path, n, 'invalid assembly line')
            return None
        cmd, branch, args = tokens[0], tokens[1], tokens[2:]
        if cmd not in {'branch', 'merge', 'rebase'}:
            parse_error(path, n, 'unknown command: {}'.format(cmd))
            return None

        node = nodes.get(branch)
        if node is None:
            node = empty_node(branch)
            nodes[branch] = node

        if cmd == 'branch' or cmd == 'rebase':
            # define the branch base
            if node['base']:
                parse_error(path, n, 'branch base/type cannot be redefined')
                return None
            if len(args) != 1:
                parse_error(path, n, 'invalid base for branch {}'.format(branch))
                return None
            node['base'] = args[0]
            node['rebase'] = (cmd == 'rebase')
        elif cmd == 'merge':
            # add dependencies
            for arg in args:
                if arg in node['merge']:
                    parse_error(path, n, 'duplicate merge of {} into {}'.format(arg, branch))
                    return None
            node['merge'].extend(args)

    return nodes


def leaf_node(node):
    return len(node['deps']) == 0

def empty_node(name):
    return {'name': name,
            'base': None,
            'rebase': False,
            'merge': [],
            'deps': [],
            'state': {'dirty': False,
                      'used': False,
                      'missing': None}}


def assembly_graph(nodes, targets=None):
    # convert all nodes
    for branch in list(nodes):
        node = nodes[branch]
        deps = []

        # convert base
        if node['base'] is not None:
            base_name = node['base']
            base_node = nodes.get(base_name)
            if base_node is None:
                base_node = empty_node(base_name)
                nodes[base_name] = base_node
            node['base'] = base_node
            deps.append(base_node)

        # direct merge dependencies
        merge = []
        for branch_name in node.get('merge'):
            branch_node = nodes.get(branch_name)
            if branch_node is None:
                branch_node = empty_node(branch_name)
                nodes[branch_name] = branch_node
            merge.append(branch_node)
        node['merge'] = merge
        deps.extend(merge)

        # all dependencies (in order)
        node['deps'] = deps

    # filter targets
    if targets is None:
        left = set(nodes)
    else:
        left = set(targets)
        branches = set(nodes)
        for branch in targets:
            if branch not in branches:
                error('unknown branch {}'.format(branch))
                return None

    # split into disjoint groups
    groups = []
    while len(left):
        start = left.pop()
        if leaf_node(nodes[start]):
            continue

        # check for cycles
        seen = set()
        stack = collections.deque([start])
        while len(stack):
            branch = stack.popleft()
            if branch in seen:
                error('dependency cycle detected for branch {}'.format(branch))
                return None
            seen.add(branch)
            for dep in nodes[branch]['deps']:
                if not leaf_node(dep):
                    stack.append(dep['name'])

        groups.append(seen)
        left -= seen

    # coalesce groups
    left = list(groups)
    groups = []
    while len(left):
        buf = left.pop()
        group = None
        for tmp in groups:
            if not buf.isdisjoint(tmp):
                group = tmp
                break
        if group is not None:
            group |= buf
        else:
            groups.append(buf)

    # find roots
    roots = []
    for group in groups:
        connected = set()
        for branch in group:
            for dep in nodes[branch]['deps']:
                connected.add(dep['name'])
        roots.extend(group - connected)

    return [nodes[name] for name in sorted(roots)]


class ANSI:
    bold  = "\033[;1m"
    green = "\033[0;32m"
    red   = "\033[1;31m"
    reset = "\033[0;0m"

def color_node(node):
    name = node['name']
    if not sys.stdout.isatty():
        return name
    elif node['state']['missing']:
        return ANSI.red + name + ANSI.reset
    elif node['state']['dirty']:
        return ANSI.bold + name + ANSI.reset
    elif node['state']['used']:
        return ANSI.green + name + ANSI.reset
    else:
        return name

def dump_graph(graph, root=None, depth=0):
    roots = list(reversed(graph))
    if root is None:
        root = roots

    while len(roots):
        node = roots.pop()
        prefix = '  ' * depth

        # calculate an extended suffix
        suffix = ''
        base_node = node['base']
        while base_node is not None:
            base_name = color_node(base_node)
            suffix += ' <- ' if node['rebase'] else ' .. '
            if base_node['base'] is not None and len(base_node['merge']) != 0:
                # split the branch into a fake root
                suffix += '[' + base_name + ']'
                root.append(base_node)
                break
            suffix += base_name
            base_node = base_node['base']

        print(prefix + color_node(node) + suffix)

        merge = node['merge']
        if len(merge):
            dump_graph(merge, root, depth + 1)


def topo_sort(graph, seen=None):
    if seen is None:
        seen = set()
    nodes = []
    if type(graph) is not list:
        graph = [graph]
    for node in graph:
        name = node['name']
        if name in seen:
            continue
        seen.add(name)
        for dep in node['deps']:
            nodes.extend(topo_sort(dep, seen))
        nodes.append(node)
    return nodes


def mark_tree_dirty(node, graph):
    if type(graph) is not list:
        graph = [graph]
    dirty = False
    for root in graph:
        if root is node or mark_tree_dirty(node, root['merge']) or \
           (root['rebase'] and mark_tree_dirty(node, root['base'])):
            root['state']['dirty'] = dirty = True
    return dirty


def needs_merge(dst, branch):
    proc = sp.run(['git', 'merge-base', '--is-ancestor', branch, dst],
                  stderr=sp.DEVNULL)
    if proc.returncode not in [0, 1]:
        return None
    return proc.returncode != 0


def fork_point(dst, base):
    proc = sp.run(['git', 'merge-base', '--fork-point', base, dst],
                  stdout=sp.PIPE, stderr=sp.DEVNULL)
    fork_point = proc.stdout.decode('ascii').rstrip()
    if proc.returncode != 0 or len(fork_point) == 0:
        return None
    return fork_point


def branch_tip(name):
    proc = sp.run(['git', 'rev-parse', '--verify', name],
                  stdout=sp.PIPE, stderr=sp.DEVNULL)
    tip = proc.stdout.decode('ascii').rstrip()
    if proc.returncode != 0 or len(tip) == 0:
        return None
    return tip


def needs_rebase(dst, base):
    tip = branch_tip(base)
    if tip is None:
        return None, None, None
    fp = fork_point(dst, base)
    if fp is None:
        return None, None, None
    return tip != fp, tip, fp


def branch_exists(name):
    proc = sp.run(['git', 'rev-parse', '--verify', name],
                  stdout=sp.DEVNULL, stderr=sp.DEVNULL)
    return proc.returncode == 0


def node_missing(node):
    if node['state']['missing'] is None:
        node['state']['missing'] = not branch_exists(node['name'])

def nodes_missing(nodes):
    for node in nodes:
        node_missing(node)


def update_state(ordered_nodes, graph):
    for node in ordered_nodes:
        if leaf_node(node):
            continue

        if node['base'] is not None:
            if not node['rebase']:
                # base should be created when missing
                nodes_missing([node, node['base']])
                if node['state']['missing']:
                    node['base']['state']['used'] = True
                    mark_tree_dirty(node, graph)
            else:
                # always rebase
                if node['state']['missing'] or node['base']['state']['missing']:
                    ret = None
                else:
                    ret = needs_rebase(node['name'], node['base']['name'])[0]
                if ret is not False:
                    if ret is None:
                        nodes_missing([node, node['base']])
                    node['base']['state']['used'] = True
                    mark_tree_dirty(node, graph)

        # merge dependencies
        for dep in node['merge']:
            if node['state']['missing'] or dep['state']['missing']:
                ret = None
            else:
                ret = needs_merge(node['name'], dep['name'])
            if ret is not False:
                if ret is None:
                    nodes_missing([node, dep])
                dep['state']['used'] = True
                mark_tree_dirty(node, graph)


def check_missing(nodes, create):
    state = True
    for node in nodes:
        if node['state']['missing']:
            if node['base'] is None:
                state = False
                for ref in nodes:
                    if node in ref['deps']:
                        break
                else:
                    ref = None
                if ref is None:
                    error('branch {} is required but does not exist'.format(color_node(node)))
                else:
                    error('branch {} is required by {} but does not exist'.format(color_node(node), color_node(ref)))
            elif not create:
                state = False
                error('branch {} needs creation from {}'.format(color_node(node), color_node(node['base'])))
    return state


def check_dirty(nodes):
    for node in nodes:
        if node['state']['dirty']:
            return True
    return False


def current_branch():
    proc = sp.run(['git', 'rev-parse', '--abbrev-ref', 'HEAD'],
                  stdout=sp.PIPE, stderr=sp.DEVNULL)
    name = proc.stdout.decode('ascii').rstrip()
    if proc.returncode != 0 or len(name) == 0:
        return None
    return name


def read_state(root):
    state_path = os.path.join(root, '.git', 'as-cache', 'state')
    if os.path.exists(state_path):
        return json.load(open(state_path))
    else:
        return {}


def save_state(root, state):
    cache_dir = os.path.join(root, '.git', 'as-cache')
    dir_exists = os.path.exists(cache_dir)
    if not state:
        if dir_exists:
            shutil.rmtree(cache_dir)
        return
    if not dir_exists:
        os.mkdir(cache_dir)
    state_path = os.path.join(cache_dir, 'state')
    json.dump(state, open(state_path, "w"))


def switch_to_branch(name):
    proc = sp.run(['git', 'checkout', '-q', '--no-guess', name],
                  stdout=sp.DEVNULL, stderr=sp.DEVNULL)
    return proc.returncode == 0


def update_node(node, state, dry_run):
    if not node['state']['dirty']:
        return True

    # logging helper
    def dry_info(msg):
        if dry_run:
            warning(msg)
        else:
            info(msg)

    # switch branch if needed
    if node['name'] == state['last_branch']:
        exists = True
    elif dry_run:
        exists = branch_exists(node['name'])
    else:
        debug('switching to branch {}'.format(node['name']))
        exists = switch_to_branch(node['name'])

    if not exists:
        # branch is missing, see if it can be bootstrapped
        if node['base'] is None:
            return False
        else:
            warning('creating branch {} from {}'.format(color_node(node), color_node(node['base'])))
            if not dry_run:
                proc = sp.run(['git', 'checkout', '-q', '--no-guess', '-b', node['name'], node['base']['name']])
                if proc.returncode != 0:
                    return False
            state['last_branch'] = node['name']
    else:
        state['last_branch'] = node['name']

        # rebase when required
        if node['rebase'] and node['base'] is not None:
            dirty, tip, fp = needs_rebase(node['name'], node['base']['name'])
            if dirty is None:
                return False
            elif dirty:
                dry_info('rebasing {} onto {}'.format(color_node(node), color_node(node['base'])))
                if not dry_run:
                    proc = sp.run(['git', 'rebase', '-q', '--rebase-merges',
                                   '--onto', node['base']['name'], fp, node['name']])
                    if proc.returncode != 0:
                        return False


    # merge dependencies
    for dep in node['merge']:
        if not exists or dep['state']['dirty']:
            # branch is new or dependency has been updated earlier on,
            # there's no need to peform another check: we need to merge
            pass
        elif not needs_merge(node['name'], dep['name']):
            continue

        dry_info('merging {} into {}'.format(color_node(dep), color_node(node)))
        if not dry_run:
            proc = sp.run(['git', 'merge', '-q', '--no-edit', dep['name']])
            if proc.returncode != 0:
                return False

    return True


def check_pending(root):
    git_root = os.path.join(root, '.git')
    if os.path.exists(os.path.join(git_root, 'MERGE_HEAD')):
        error('merge in progress, refusing to continue')
        return True
    elif os.path.exists(os.path.join(git_root, 'rebase-apply')):
        error('rebase in progress, refusing to continue')
        return True
    elif os.path.exists(os.path.join(git_root, 'BISECT_LOG')):
        error('bisect in progress, refusing to continue')
        return True
    return False


def main(argv):
    ap = argparse.ArgumentParser(description=APP_DSC)
    ap.add_argument('-a', '--assembly', metavar='PATH',
                    help='explicit path to assembly file')
    ap.add_argument('-c', '--create', action='store_true',
                    help='create required branches')
    ap.add_argument('-n', '--dry-run', action='store_true',
                    help='do not modify the repository')
    ap.add_argument('-s', '--state', action='store_true',
                    help='show repository state')
    ap.add_argument('-v', '--verbose', default=0, action='count',
                    help='increase verbosity')
    ap.add_argument('--version', action='version', version=APP_VER)
    ap.add_argument('target', nargs='*',
                    help='branch to update')
    args = ap.parse_args(argv[1:])

    # logging
    levels = (logging.WARNING, logging.INFO, logging.DEBUG)
    logging.basicConfig(level=levels[min(len(levels)-1, args.verbose)],
                        format='{}: %(message)s'.format(APP_SIG))

    # assembly path
    root = repo_root()
    if root is None:
        return 1

    if args.assembly:
        path = args.assembly
    else:
        path = assembly_path(root)
        if path is None:
            error('no assembly instructions')
            return 1
        path = os.path.relpath(path)
        debug('reading instructions from {}'.format(path))

    # build the list of nodes and resulting graph
    nodes = parse_assembly(path)
    if nodes is None:
        return 1
    targets = set(args.target) if len(args.target) else None
    graph = assembly_graph(nodes, targets)
    if graph is None:
        return 1
    if len(graph) == 0:
        error('nothing to do')
        return 1

    # update and check current state
    ordered_nodes = topo_sort(graph)
    update_state(ordered_nodes, graph)
    if args.state:
        dump_graph(graph)
        return 0
    if not check_missing(ordered_nodes, args.create):
        return 1
    state = read_state(root)
    state['last_branch'] = current_branch()
    if not check_dirty(ordered_nodes):
        if state.get('start_branch', state['last_branch']) == state['last_branch']:
            info('already up to date')
        else:
            # always warn when restoring the initial branch by itself
            warning('restoring initial branch {}'.format(state['start_branch']))
            if not args.dry_run:
                switch_to_branch(state['start_branch'])
        if not args.dry_run:
            save_state(root, None)
        return 0

    # check whether we're in the middle of other stateful activities
    if check_pending(root):
        return 1

    # save the initial branch
    if 'start_branch' not in state:
        state['start_branch'] = state['last_branch']

    # perform the required operations
    for node in ordered_nodes:
        if not update_node(node, state, args.dry_run):
            if not args.dry_run:
                save_state(root, state)
            return 1
    if state['start_branch'] != state['last_branch']:
        info('restoring initial branch {}'.format(state['start_branch']))
        if not args.dry_run:
            switch_to_branch(state['start_branch'])
    if not args.dry_run:
        save_state(root, None)


if __name__ == '__main__':
    exit(main(sys.argv))
