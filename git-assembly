#!/usr/bin/env python3
import subprocess as sp
import collections
import argparse
import os, sys

import logging
from logging import error, warning, info, debug

APP_DSC = "update git branches using high-level assembly instructions"
APP_SIG = "git-assembly"
APP_VER = "1.0"


def repo_root():
    try:
        line = sp.check_output(['git', 'rev-parse', '--show-toplevel'])
    except sp.CalledProcessError as e:
        return None
    return line.decode(sys.getfilesystemencoding()).rstrip()


def assembly_path(root):
    path = os.path.join(root, '.git', 'assembly')
    if os.path.exists(path):
        return path
    path = os.path.join(root, '.gitassembly')
    if os.path.exists(path):
        return path
    return None


def parse_error(path, line, msg):
    error('{}:{}: {}'.format(path, line, msg))

def os_error(e):
    error(str(e))


def parse_assembly(path):
    try:
        fd = open(path)
    except OSError as e:
        os_error(e)
        return None

    nodes = {}
    for n, line in enumerate(fd, 1):
        # strip comments
        line = line[0:line.find('#')].strip()
        if len(line) == 0:
            continue

        # basic tokenization
        tokens = line.split()
        if len(tokens) < 3:
            parse_error(path, n, 'invalid assembly line')
            return None
        cmd, branch, args = tokens[0], tokens[1], tokens[2:]
        if cmd not in {'branch', 'merge', 'rebase'}:
            parse_error(path, n, 'unknown command: {}'.format(cmd))
            return None

        node = nodes.get(branch)
        if node is None:
            node = empty_node(branch)
            nodes[branch] = node

        if cmd == 'branch' or cmd == 'rebase':
            # define the branch base
            if node['base']:
                parse_error(path, n, 'branch base/type cannot be redefined')
                return None
            if len(args) != 1:
                parse_error(path, n, 'invalid base for branch {}'.format(branch))
                return None
            node['base'] = args[0]
            node['rebase'] = (cmd == 'rebase')
        elif cmd == 'merge':
            # add dependencies
            for arg in args:
                if arg in node['merge']:
                    parse_error(path, n, 'duplicate merge of {} into {}'.format(arg, branch))
                    return None
            node['merge'].extend(args)

    return nodes


def leaf_node(node):
    return len(node['deps']) == 0

def empty_node(name):
    return {'name': name,
            'base': None,
            'rebase': False,
            'merge': [],
            'deps': [],
            'state': {'dirty': False,
                      'used': False,
                      'missing': None}}


def assembly_graph(nodes, targets=None):
    # convert all nodes
    for branch in list(nodes):
        node = nodes[branch]
        deps = []

        # convert base
        if node['base'] is not None:
            base_name = node['base']
            base_node = nodes.get(base_name)
            if base_node is None:
                base_node = empty_node(base_name)
                nodes[base_name] = base_node
            node['base'] = base_node
            deps.append(base_node)

        # direct merge dependencies
        merge = []
        for branch_name in node.get('merge'):
            branch_node = nodes.get(branch_name)
            if branch_node is None:
                branch_node = empty_node(branch_name)
                nodes[branch_name] = branch_node
            merge.append(branch_node)
        node['merge'] = merge
        deps.extend(merge)

        # all dependencies (in order)
        node['deps'] = deps

    # filter targets
    if targets is None:
        left = set(nodes)
    else:
        left = set(targets)
        branches = set(nodes)
        for branch in targets:
            if branch not in branches:
                error('unknown branch {}'.format(branch))
                return None

    # split into disjoint groups
    groups = []
    while len(left):
        start = left.pop()
        if leaf_node(nodes[start]):
            continue

        # check for cycles
        seen = set()
        stack = collections.deque([start])
        while len(stack):
            branch = stack.popleft()
            if branch in seen:
                error('dependency cycle detected for branch {}'.format(branch))
                return None
            seen.add(branch)
            for dep in nodes[branch]['deps']:
                if not leaf_node(dep):
                    stack.append(dep['name'])

        groups.append(seen)
        left -= seen

    # coalesce groups
    left = list(groups)
    groups = []
    while len(left):
        buf = left.pop()
        group = None
        for tmp in groups:
            if not buf.isdisjoint(tmp):
                group = tmp
                break
        if group is not None:
            group |= buf
        else:
            groups.append(buf)

    # find roots
    roots = []
    for group in groups:
        connected = set()
        for branch in group:
            for dep in nodes[branch]['deps']:
                connected.add(dep['name'])
        roots.extend(group - connected)

    return [nodes[name] for name in sorted(roots)]


class ANSI:
    bold  = "\033[;1m"
    green = "\033[0;32m"
    red   = "\033[1;31m"
    reset = "\033[0;0m"

def color_node(node):
    name = node['name']
    if not sys.stdout.isatty():
        return name
    elif node['state']['missing']:
        return ANSI.red + name + ANSI.reset
    elif node['state']['dirty']:
        return ANSI.bold + name + ANSI.reset
    elif node['state']['used']:
        return ANSI.green + name + ANSI.reset
    else:
        return name

def dump_graph(graph, root=None, depth=0):
    roots = list(reversed(graph))
    if root is None:
        root = roots

    while len(roots):
        node = roots.pop()
        prefix = '  ' * depth

        # calculate an extended suffix
        suffix = ''
        base_node = node['base']
        while base_node is not None:
            base_name = color_node(base_node)
            suffix += ' <- ' if node['rebase'] else ' .. '
            if base_node['base'] is not None and len(base_node['merge']) != 0:
                # split the branch into a fake root
                suffix += '[' + base_name + ']'
                root.append(base_node)
                break
            suffix += base_name
            base_node = base_node['base']

        print(prefix + color_node(node) + suffix)

        merge = node['merge']
        if len(merge):
            dump_graph(merge, root, depth + 1)


def topo_sort(graph, seen=None):
    if seen is None:
        seen = set()
    nodes = []
    if type(graph) is not list:
        graph = [graph]
    for node in graph:
        name = node['name']
        if name in seen:
            continue
        seen.add(name)
        for dep in node['deps']:
            nodes.extend(topo_sort(dep, seen))
        nodes.append(node)
    return nodes


def mark_tree_dirty(node, graph):
    if type(graph) is not list:
        graph = [graph]
    dirty = False
    for root in graph:
        if root is node or mark_tree_dirty(node, root['merge']) or \
           (root['rebase'] and mark_tree_dirty(node, root['base'])):
            root['state']['dirty'] = dirty = True
    return dirty


def needs_merge(dst, branch):
    if not branch_exists(branch):
        return None
    if not branch_exists(dst):
        return None
    return False


def needs_rebase(dst, base):
    if not branch_exists(base):
        return None
    if not branch_exists(dst):
        return None
    return False


def branch_exists(name):
    proc = sp.run(['git', 'show-ref', '--quiet', name], stdout=sp.DEVNULL)
    return proc.returncode == 0


def node_missing(node):
    if node['state']['missing'] is None:
        node['state']['missing'] = not branch_exists(node['name'])

def nodes_missing(nodes):
    for node in nodes:
        node_missing(node)


def update_state(ordered_nodes, graph):
    for node in ordered_nodes:
        if leaf_node(node):
            continue

        if node['base'] is not None:
            if not node['rebase']:
                # base should be created when missing
                nodes_missing([node, node['base']])
                if node['state']['missing']:
                    node['base']['state']['used'] = True
                    mark_tree_dirty(node, graph)
            else:
                # always rebase
                if node['state']['missing'] or node['base']['state']['missing']:
                    ret = None
                else:
                    ret = needs_rebase(node['name'], node['base']['name'])[0]
                if ret is not False:
                    if ret is None:
                        nodes_missing([node, node['base']])
                    node['base']['state']['used'] = True
                    mark_tree_dirty(node, graph)

        # merge dependencies
        for dep in node['merge']:
            if node['state']['missing'] or dep['state']['missing']:
                ret = None
            else:
                ret = needs_merge(node['name'], dep['name'])
            if ret is not False:
                if ret is None:
                    nodes_missing([node, dep])
                dep['state']['used'] = True
                mark_tree_dirty(node, graph)


def check_state(nodes, create):
    state = True
    for node in nodes:
        if node['state']['missing']:
            if node['base'] is None:
                state = False
                for ref in nodes:
                    if node in ref['deps']:
                        break
                else:
                    ref = None
                if ref is None:
                    error('branch {} is required but does not exist'.format(color_node(node)))
                else:
                    error('branch {} is required by {} but does not exist'.format(color_node(node), color_node(ref)))
            elif not create:
                state = False
                error('branch {} needs creation from {}'.format(color_node(node), color_node(node['base'])))
    return state


def main(argv):
    ap = argparse.ArgumentParser(description=APP_DSC)
    ap.add_argument('-a', '--assembly', metavar='PATH',
                    help='explicit path to assembly file')
    ap.add_argument('-c', '--create', action='store_true',
                    help='create required branches')
    ap.add_argument('-n', '--dry-run', action='store_true',
                    help='do not modify the repository')
    ap.add_argument('-s', '--state', action='store_true',
                    help='show repository state')
    ap.add_argument('-v', '--verbose', default=0, action='count',
                    help='increase verbosity')
    ap.add_argument('--version', action='version', version=APP_VER)
    ap.add_argument('target', nargs='*',
                    help='branch to update')
    args = ap.parse_args(argv[1:])

    # logging
    levels = (logging.WARNING, logging.INFO, logging.DEBUG)
    logging.basicConfig(level=levels[min(len(levels)-1, args.verbose)],
                        format='{}: %(message)s'.format(APP_SIG))

    # assembly path
    root = repo_root()
    if root is None:
        return 1

    if args.assembly:
        path = args.assembly
    else:
        path = assembly_path(root)
        if path is None:
            error('no assembly instructions')
            return 1
        path = os.path.relpath(path)
        info('reading instructions from {}'.format(path))

    # build the list of nodes and resulting graph
    nodes = parse_assembly(path)
    if nodes is None:
        return 1
    targets = set(args.target) if len(args.target) else None
    graph = assembly_graph(nodes, targets)
    if graph is None:
        return 1
    if len(graph) == 0:
        error('nothing to do')
        return 1

    # update and check current state
    ordered_nodes = topo_sort(graph)
    update_state(ordered_nodes, graph)
    if args.state:
        dump_graph(graph)
        return 0
    if not check_state(ordered_nodes, args.create):
        return 1


if __name__ == '__main__':
    exit(main(sys.argv))
